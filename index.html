<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="jquery-ui.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="external/jquery/jquery.js"></script>
    <script src="jquery-ui.min.js"></script>
</head>

<body>
    <div id="mainContainer">
        <div id="container"></div>
        <div id="subplotContainer"></div>
    </div>
    
    
    
    <label for="normalizeCheckbox">
        Normalize (per 1k flights):
        <input id="normalizeCheckbox" type="checkbox">
    </label>
    
    <div id="controlsContainer">
        <div id="yearSlider">
            <h2>Monthly Flights Cancelled</h2>
            <div id="slider"></div>
            <p id="sliderValues"></p>
        </div>
    </div>
    
</body>

    
</div>

<script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const data = await d3.csv("airlines.csv");
    let currentData = null;

    // Declare the chart dimensions and margins.
    const width = 1280;
    const height = 900;
    const subplotWidth = 600;
    const subplotHeight = 800;
    const marginTop = 20;
    const marginRight = 20;
    const marginBottom = 30;
    const marginLeft = 400;
    const subplotMarginLeft = 40;
    const minYear = parseInt(d3.min(data, d => d["Time.Year"]));
    const maxYear = parseInt(d3.max(data, d => d["Time.Year"]));
    const airports = Array.from(new Set(data.map(d => d["Airport.Name"]))).sort(compareStrings);

    const airportDict = {};
    for (let i = 0; i < airports.length; i++) {
        let airport = airports[i];
        airportDict[airport] = i;
    }

    // console.log(airportDict);
    const minMonthlyFlightsCancelled = d3.min(data, d => parseInt(d["Statistics.Flights.Cancelled"]));
    const maxMonthlyFlightsCancelled = d3.max(data, d => parseInt(d["Statistics.Flights.Cancelled"]));
    const minMonthlyFlightsCancelledNorm = d3.min(data, d => parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
    const maxMonthlyFlightsCancelledNorm = d3.max(data, d => parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
    const attributes = ["Statistics.Flights.Cancelled"];
    let ranges = [[minMonthlyFlightsCancelled, maxMonthlyFlightsCancelled]];
    let rangesNormalized = [[minMonthlyFlightsCancelledNorm, maxMonthlyFlightsCancelledNorm]];
    let normalize = false;
    let selectedSubplotData = [];
    let selectedSubplotDataYear = null;
    let subplotYAxisExists = false;
    let subplotLinesExist = false;

    // Declare the x (horizontal position) scale.
    const x = d3.scaleLinear()
        .domain([minYear - 1, maxYear])
        .range([marginLeft, width - marginRight]);

    // Declare the y (vertical position) scale.
    const y = d3.scaleBand()
        .domain(airports)
        .range([height - marginBottom, marginTop])
        .padding(1);

    let subplotX = d3.scaleBand()
        .domain(['January', 'Febuary', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'])
        .range([subplotMarginLeft, subplotWidth - marginRight])
        .padding(1);

    // console.log(marginLeft + width);
    // console.log(subplotWidth - marginRight);

    let subplotY = null;
    
    let subplotColors = d3.scaleOrdinal(d3.schemeCategory10);

    // Create the SVG container.
    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height);

    // Add the x-axis.
    svg.append("g")
        .attr("transform", `translate(0,${height - marginBottom})`)
        .call(d3.axisBottom(x).tickFormat(d3.format(".0f")));

    // Add the y-axis.
    svg.append("g")
        .attr("transform", `translate(${marginLeft},0)`)
        .call(d3.axisLeft(y).ticks(29));

    // Create subplot SVG container
    const subplotSVG = d3.create("svg")
    .attr("width", subplotWidth)
    .attr("height", subplotHeight);

    // Add x-axis
    subplotSVG.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
    .call(d3.axisBottom(subplotX));

    // Add legend
    let subplotLegend = d3.create('svg')
    // .attr('width', 1000)
    // .attr('height', 1000)
    .attr('class', 'subplotLegend');

    // Add the y-axis.
    // subplotSVG.append("y-axis")
    // .attr("transform", `translate(${marginLeft},0)`)
    // .call(d3.axisLeft());

    // console.log(data)
    // console.log(airports)
    // console.log(minMonthlyFlightsCancelled);
    // console.log(maxMonthlyFlightsCancelled);

    $("#slider").slider({
        range: true,
        min: minMonthlyFlightsCancelled,
        max: maxMonthlyFlightsCancelled,
        values: [minMonthlyFlightsCancelled, maxMonthlyFlightsCancelled],
        step: 1,
        slide: function(event, ui) {
            document.querySelector("#sliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
            filterData("Statistics.Flights.Cancelled", ui.values);
        }
    })

    // console.log(document.getElementById("normalizeCheckbox"));

    document.getElementById("normalizeCheckbox").addEventListener('change', function() {

        // Remove everything subplot-related
        clearSubplotAndLegend();

        if (this.checked) {
            normalize = true;

            $("#slider").slider({
                min: minMonthlyFlightsCancelledNorm,
                max: maxMonthlyFlightsCancelledNorm,
                values: [minMonthlyFlightsCancelledNorm, maxMonthlyFlightsCancelledNorm],
                slide: function(event, ui) {
                    document.querySelector("#sliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                    filterData("Statistics.Flights.Cancelled", ui.values);
                }
            });

        } else {
            normalize = false;

            $("#slider").slider({
                min: minMonthlyFlightsCancelled,
                max: maxMonthlyFlightsCancelled,
                values: [minMonthlyFlightsCancelled, maxMonthlyFlightsCancelled],
                slide: function(event, ui) {
                    document.querySelector("#sliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                    filterData("Statistics.Flights.Cancelled", ui.values);
                }
            });
        }
    });

    const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

    // function checkNormalize(e) {
    //     if (e.checked) {
    //         console.log("Checked");
    //     } else {
    //         console.log("Unchecked");
    //     }
    // }

    function compareStrings(a, b) {
        return a < b;
    }

    function filterData(attr, values) {
        for (let i = 0; i < attributes.length; i++) {
            if (attr == attributes[i]) {
                if (normalize) {
                    rangesNormalized[i] = values;
                } else {
                    ranges[i] = values;
                }
            }
        }
        
        var toVisualize = data.filter(function(d) {
            return isInRange(d);
        });
        updateVis(toVisualize);
    }

    function isInRange(data) {
        for (let i = 0; i < attributes.length; i++) {
            // console.log(data);
            let totalFlights = parseInt(data['Statistics.Flights.Total']);
            // console.log('Total Flights: ' + totalFlights);
            // console.log('Cancellations: ' + data[attributes[i]]);
            // console.log('Math: ' + (data[attributes[i]] / totalFlights))
            // console.log('More math: ' + ((data[attributes[i]] / totalFlights) * 1000.0));
            if (normalize) {
                let attrPer1k = parseFloat(data[attributes[i]]) / totalFlights * 1000.0;
                // console.log(attrPer1k);
                // console.log(rangesNormalized[i][0]);
                // console.log(rangesNormalized[i][1]);

                if (attrPer1k < rangesNormalized[i][0] || attrPer1k > rangesNormalized[i][1]) {
                    return false;
                }
            } else {
                if (data[attributes[i]] < ranges[i][0] || data[attributes[i]] > ranges[i][1]) {
                    return false;
                }
            }
        }

        return true;
    }

    function updateVis(toVisualize) {
        // console.log(toVisualize);
        currentData = toVisualize;

        let svg = d3.select("svg")
        // svg.selectAll("whatever").data(toVisualize).enter().append("circle").attr("cx", function(d) {return x(parseInt(d['Time.Year']))})
        // .attr("cy", function(d) {return y(d['Airport.Name'])})
        // .attr("r", 2)
        // .exit().remove();
        svg.selectAll("circle").data(toVisualize).join("circle")
        .attr("r", 10)
        .attr("cx", function(d) {return x(parseInt(d['Time.Year']))})
        .attr("cy", function(d) {return y(d['Airport.Name'])})
        .attr("rowId", function(d) {return airportDict[d['Airport.Name']]})
        .attr('class', 'mainDot')
        .style("fill-opacity", 1/12)
        .style("stroke", "black")
        .on("mouseover", (event, d) => {
            let text = getTooltipText(d);
            // console.log(text);

            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(text).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 20) + "px");
            highlight(airportDict[d['Airport.Name']]);
        })
        .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
            unhighlight();
        })
        .on("click", (event, d) => {
            let dataYear = parseInt(d['Time.Year']);
            let newSelection = [];

            if (selectedSubplotDataYear != dataYear) {
                clearSubplotAndLegend();
                selectedSubplotDataYear = dataYear;
            }
            
            for (let i = 0; i < data.length; i++) {
                if (data[i]['Airport.Name'] == d['Airport.Name'] && data[i]['Time.Year'] == dataYear) {
                    selectedSubplotData.push(data[i]);
                }
            }
            selectedSubplotData = [...new Set(selectedSubplotData)];

            updateSubplotYAxis();
            updateSubplotXAxis();
            updateSubplotVis();
        });
    }

    function getTooltipText(data) {
        let output = `${data['Airport.Name']}<br>`;

        for (let i = 0; i < currentData.length; i++) {
            if (currentData[i]['Airport.Name'] == data['Airport.Name'] && currentData[i]['Time.Year'] == data['Time.Year']) {
                output = output + currentData[i]['Time.Month Name'] + ' ' + currentData[i]['Time.Year'] + '<br>';
            }
        }

        return output;
    }

    function highlight(rowId) {
        d3.selectAll(".mainDot").classed("highlight", d => airportDict[d['Airport.Name']] == rowId);
        d3.selectAll(".dot").classed("highlight", d => airportDict[d['Airport.Name']] == rowId);
        d3.selectAll(".dot").classed("dim", d => airportDict[d['Airport.Name']] != rowId);
        d3.selectAll('.line').classed('dim', d => airportDict[d[0]['Airport.Name']] != rowId);
    }

    function unhighlight() {
        d3.selectAll("circle").classed("highlight", false);
        d3.selectAll(".dot").classed("dim", false);
        d3.selectAll('.line').classed('dim', false);
    }

    function updateSubplotYAxis() {
        let axisAirports = Array.from(new Set(selectedSubplotData.map(d => d["Airport.Name"]))).sort(compareStrings);
        let minFlightsCancelled = d3.min(selectedSubplotData, d => parseInt(d['Statistics.Flights.Cancelled']));
        let maxFlightsCancelled = d3.max(selectedSubplotData, d => parseInt(d['Statistics.Flights.Cancelled']));

        if (normalize) {
            minFlightsCancelled = d3.min(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            maxFlightsCancelled = d3.max(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
        }
        // console.log('Min and Max: ' + minFlightsCancelled + ' ' + maxFlightsCancelled);

        subplotY = d3.scaleLinear()
        .domain([minFlightsCancelled, maxFlightsCancelled])
        .range([subplotHeight - marginBottom, marginTop]);

        if (!subplotYAxisExists) {
            subplotSVG.append('g').attr("class", 'y-axis');
            subplotYAxisExists = true;
        }

        subplotSVG.select(".y-axis")
        .attr("transform", `translate(${subplotMarginLeft},0)`)
        .call(d3.axisLeft(subplotY).ticks(10));
    }

    function updateSubplotXAxis() {
        let months = [];
        if (selectedSubplotDataYear == 2003) {
            months = ['June', 'July', 'August', 'September', 'October', 'November', 'December'];
        } else if (selectedSubplotDataYear == 2016) {
            months = ['January'];
        } else {
            months = ['January', 'Febuary', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        }

        subplotX = d3.scaleBand()
        .domain(months)
        .range([subplotMarginLeft, subplotWidth - marginRight])
        .padding(1);

        // console.log(months);
        subplotSVG.select(".x-axis")
        .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
        .call(d3.axisBottom(subplotX));
    }

    function updateSubplotVis() {
        let selectedAirports = Array.from(new Set(selectedSubplotData.map(data => data['Airport.Name'])));
        subplotColors.domain(selectedAirports);
        // console.log(selectedAirports);
        // console.log("Colors:");
        // console.log(subplotColors.domain());
        // console.log(subplotColors.range());

        let arrayedSubplotData = [];
        let size = 12;

        if (selectedSubplotDataYear == 2003) {
            size = 7;
        } else if (selectedSubplotDataYear == 2016) {
            size = 1;
        }

        let selection = [selectedSubplotData[0]]
        for (let i = 1; i < selectedSubplotData.length; i++) {
            selection.push(selectedSubplotData[i]);

            if ((i + 1) % size == 0) {
                arrayedSubplotData.push(selection);
                selection = [];
            }
        }

        // console.log('Arrayed data:');
        // console.log(arrayedSubplotData);

        let line = d3.line()
        .x(d => subplotX(d['Time.Month Name']))
        .y(d => subplotY(d['Statistics.Flights.Cancelled']));

        if (normalize) {
            line = d3.line()
            .x(d => subplotX(d['Time.Month Name']))
            .y(d => subplotY(parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
        }

        // Add lines
        subplotSVG.selectAll('.line')
        .data(arrayedSubplotData)
        .enter()
        .append('path')
        .attr('class', 'line')
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke-width', '4px')
        .attr('stroke', d => subplotColors(d[0]['Airport.Name']));

        // Add monthly dots
        subplotSVG.selectAll('.dot')
        .data(selectedSubplotData)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('r', 4)
        .attr('cx', function(d) {return subplotX(d['Time.Month Name'])})
        .attr('cy', function(d) {
            if (normalize) {
                return subplotY(parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            } else {
                return subplotY(parseFloat(d["Statistics.Flights.Cancelled"]))
            }
        })
        .style('fill', d => subplotColors(d['Airport.Name']))
        .style('stroke', 'black');

        updateSubplotLegend(selectedAirports);
    }

    function updateSubplotLegend(selectedAirports) {
        console.log(selectedAirports);
        subplotLegend.selectAll('rect')
        .data(selectedAirports)
        .enter()
        .append('rect')
        .attr('x', 0)
        .attr('y', (d, i) => i * 15 + 5)
        .attr('width', 20)
        .attr('height', 10)
        .attr('fill', d => subplotColors(d))
        .attr('class', 'legendBar')
        .on('mouseover', (event, d) => {
            highlight(airportDict[d]);
        })
        .on('mouseout', () => {
            unhighlight();
        });

        subplotLegend.selectAll('text')
        .data(selectedAirports)
        .enter()
        .append('text')
        .attr('x', 22)
        .attr('y', (d, i) => i * 15 + 15)
        .attr('class', 'legendLabel')
        .text(d => d)
        .style('font-size', '12px')
        .on('mouseover', (event, d) => {
            highlight(airportDict[d]);
        })
        .on('mouseout', () => {
            unhighlight();
        });
    }

    function clearSubplotAndLegend() {
        subplotSVG.selectAll('.line').remove();
        subplotSVG.selectAll('.dot').remove();
        subplotLegend.selectAll('.legendBar').remove();
        subplotLegend.selectAll('.legendLabel').remove();
        selectedSubplotData = [];
    }

    
    // Append the SVG element.
    container.append(svg.node());
    subplotContainer.append(subplotSVG.node());
    subplotContainer.append(subplotLegend.node());
</script>



