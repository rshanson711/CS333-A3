<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="jquery-ui.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="external/jquery/jquery.js"></script>
    <script src="jquery-ui.min.js"></script>
</head>

<body>
    <div id="mainContainer">
        <div id="container"></div>
        <div id="subplotMainContainer">
            <div id="firstSubplotContainer"></div>
            <div id="secondSubplotContainer"></div>
        </div>
    </div> 
    <div id="controlsContainer">
        <label for="normalizeCheckbox">
            <input id="normalizeCheckbox" type="checkbox">
            Normalize (per 1k flights)
        </label>
        <label for="resetButton">
            <button id="resetButton">Reset Settings</button>
        </label>
        <div id="sliderContainer">
            <div id="monthlyCancellationsSliderContainer">
                <h2>Monthly Flights Cancelled</h2>
                <div id="monthlyCancellationsSlider"></div>
                <p id="monthlyCancellationsSliderValues"></p>
            </div>
            <div id="monthlyDelaysSliderContainer">
                <h2>Monthly Flights Delayed</h2>
                <div id="monthlyDelaysSlider"></div>
                <p id="monthlyDelaysSliderValues"></p>
            </div>
            <div id="monthlyDiversionsSliderContainer">
                <h2>Monthly Flights Diverted</h2>
                <div id="monthlyDiversionsSlider"></div>
                <p id="monthlyDiversionsSliderValues"></p>
            </div>
            <div id="monthlyOnTimeSliderContainer">
                <h2>Monthly Flights On-Time</h2>
                <div id="monthlyOnTimeSlider"></div>
                <p id="monthlyOnTimeSliderValues"></p>
            </div>
        </div>
    </div>
    
</body>

    
</div>

<script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const data = await d3.csv("airlines.csv");
    let currentData = null;

    // Declare the chart dimensions and margins.
    const width = 1000;
    const height = 900;
    const subplotWidth = 600;
    const subplotHeight = 400;
    const marginTop = 20;
    const marginRight = 20;
    const marginBottom = 30;
    const marginLeft = 350;
    const subplotMarginLeft = 40;
    const minYear = parseInt(d3.min(data, d => d["Time.Year"]));
    const maxYear = parseInt(d3.max(data, d => d["Time.Year"]));
    const airports = Array.from(new Set(data.map(d => d["Airport.Name"]))).sort(compareStrings);

    const airportDict = {};
    for (let i = 0; i < airports.length; i++) {
        let airport = airports[i];
        airportDict[airport] = i;
    }

    const monthDict = {
        "January": "Jan",
        "Febuary": "Feb",
        "March": "Mar",
        "April": "Apr",
        "May": "May",
        "June": "June",
        "July": "July",
        "August": "Aug",
        "September": "Sept",
        "October": "Oct",
        "November": "Nov",
        "December": "Dec"
    };

    // Monthly Flights Cancelled data
    const minMonthlyFlightsCancelled = d3.min(data, d => parseInt(d["Statistics.Flights.Cancelled"]));
    const maxMonthlyFlightsCancelled = d3.max(data, d => parseInt(d["Statistics.Flights.Cancelled"]));
    const minMonthlyFlightsCancelledNorm = d3.min(data, d => Math.round(parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
    const maxMonthlyFlightsCancelledNorm = d3.max(data, d => Math.round(parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));

    // Monthly Flights Delayed data
    const minMonthlyFlightsDelayed = d3.min(data, d => parseInt(d["Statistics.Flights.Delayed"]));
    const maxMonthlyFlightsDelayed = d3.max(data, d => parseInt(d["Statistics.Flights.Delayed"]));
    const minMonthlyFlightsDelayedNorm = d3.min(data, d => Math.round(parseFloat(d["Statistics.Flights.Delayed"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
    const maxMonthlyFlightsDelayedNorm = d3.max(data, d => Math.round(parseFloat(d["Statistics.Flights.Delayed"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));

    // Monthly Flights Diverted data
    const minMonthlyFlightsDiverted = d3.min(data, d => parseInt(d["Statistics.Flights.Diverted"]));
    const maxMonthlyFlightsDiverted = d3.max(data, d => parseInt(d["Statistics.Flights.Diverted"]));
    const minMonthlyFlightsDivertedNorm = d3.min(data, d => Math.round(parseFloat(d["Statistics.Flights.Diverted"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
    const maxMonthlyFlightsDivertedNorm = d3.max(data, d => Math.round(parseFloat(d["Statistics.Flights.Diverted"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));

    // Monthly Flights On-Time data
    const minMonthlyFlightsOnTime = d3.min(data, d => parseInt(d["Statistics.Flights.On Time"]));
    const maxMonthlyFlightsOnTime = d3.max(data, d => parseInt(d["Statistics.Flights.On Time"]));
    const minMonthlyFlightsOnTimeNorm = d3.min(data, d => Math.round(parseFloat(d["Statistics.Flights.On Time"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
    const maxMonthlyFlightsOnTimeNorm = d3.max(data, d => Math.round(parseFloat(d["Statistics.Flights.On Time"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));


    const attributes = ["Statistics.Flights.Cancelled", "Statistics.Flights.Delayed", "Statistics.Flights.Diverted", "Statistics.Flights.On Time"];
    let ranges = [[minMonthlyFlightsCancelled, maxMonthlyFlightsCancelled],
        [minMonthlyFlightsDelayed, maxMonthlyFlightsDelayed],
        [minMonthlyFlightsDiverted, maxMonthlyFlightsDiverted],
        [minMonthlyFlightsOnTime, maxMonthlyFlightsOnTime]];
    let rangesNormalized = [[minMonthlyFlightsCancelledNorm, maxMonthlyFlightsCancelledNorm],
        [minMonthlyFlightsDelayedNorm, maxMonthlyFlightsDelayedNorm],
        [minMonthlyFlightsDivertedNorm, maxMonthlyFlightsDivertedNorm],
        [minMonthlyFlightsOnTimeNorm, maxMonthlyFlightsOnTimeNorm]];
    let normalize = false;
    let selectedSubplotData = [];
    let selectedSubplotDataYear = null;
    let cancelledSubplotYAxisExists = false;
    let delayedSubplotYAxisExists = false;
    let divertedSubplotYAxisExists = false;
    let onTimeSubplotYAxisExists = false;
    let subplotLinesExist = false;
    let mainPlotHues = ["#F1EEF6", "#D7B5D8", "#DF65B0", "#CE1256"]

    // Declare the x (horizontal position) scale.
    const x = d3.scaleLinear()
        .domain([minYear - 1, maxYear])
        .range([marginLeft, width - marginRight]);

    // Declare the y (vertical position) scale.
    const y = d3.scaleBand()
        .domain(airports)
        .range([height - marginBottom, marginTop])
        .padding(1);

    // Declare main plot color scale (4 bins)
    const mainPlotColorScale = d3.scaleOrdinal()
    .domain([1/4, 2/4, 3/4, 1])
    .range(mainPlotHues);

    let subplotX = d3.scaleBand()
        .domain(["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"])
        .range([subplotMarginLeft, subplotWidth - marginRight])
        .padding(1);

    // console.log(marginLeft + width);
    // console.log(subplotWidth - marginRight);

    let cancelledSubplotY = null;
    let delayedSubplotY = null;
    let divertedSubplotY = null;
    let onTimeSubplotY = null;
    
    let subplotColors = d3.scaleOrdinal(d3.schemeCategory10);

    // Create the SVG container.
    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height);

    // Add the x-axis.
    svg.append("g")
        .attr("transform", `translate(0,${height - marginBottom})`)
        .call(d3.axisBottom(x).tickFormat(d3.format(".0f")));

    // Add the y-axis.
    svg.append("g")
        .attr("transform", `translate(${marginLeft},0)`)
        .call(d3.axisLeft(y).ticks(29));

    // Add main plot legend
    let mainPlotLegend = d3.create('svg')
    .attr('class', 'mainPlotLegend');

    mainPlotLegend.selectAll('rect')
    .data(mainPlotHues)
    .enter()
    .append('rect')
    .attr('x', 0)
    .attr('y', (d, i) => i * 15 + 5)
    .attr('width', 20)
    .attr('height', 10)
    .attr('fill', d => d)
    .attr('stroke', 'black');

    let mainPlotLegendLabels = ['1-3 Months', '4-6 Months', '7-9 Months', '10-12 Months'];
    mainPlotLegend.selectAll('text')
    .data(mainPlotLegendLabels)
    .enter()
    .append('text')
    .attr('x', 22)
    .attr('y', (d, i) => i * 15 + 15)
    .text(d => d)
    .style('font-size', '12px');

    // Create cancelled subplot SVG container
    const cancelledSubplotSVG = d3.create("svg")
    .attr("width", subplotWidth)
    .attr("height", subplotHeight);

    // Add x-axis
    cancelledSubplotSVG.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
    .call(d3.axisBottom(subplotX));
    
    // Add title
    cancelledSubplotSVG.append("text")
    .attr('x', subplotWidth / 2)
    .attr('y', 10)
    .attr('font-size', '12px')
    .attr('text-anchor', 'middle')
    .attr('class', 'title')
    .text("Cancelled Flights");

    // Create delayed subplot SVG container
    const delayedSubplotSVG = d3.create("svg")
    .attr("width", subplotWidth)
    .attr("height", subplotHeight);

    // Add x-axis
    delayedSubplotSVG.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
    .call(d3.axisBottom(subplotX));

    // Add title
    delayedSubplotSVG.append("text")
    .attr('x', subplotWidth / 2)
    .attr('y', 10)
    .attr('font-size', '12px')
    .attr('text-anchor', 'middle')
    .attr('class', 'title')
    .text("Delayed Flights");

    // Create diverted subplot SVG container
    const divertedSubplotSVG = d3.create("svg")
    .attr("width", subplotWidth)
    .attr("height", subplotHeight);

    // Add x-axis
    divertedSubplotSVG.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
    .call(d3.axisBottom(subplotX));

    // Add title
    divertedSubplotSVG.append("text")
    .attr('x', subplotWidth / 2)
    .attr('y', 10)
    .attr('font-size', '12px')
    .attr('text-anchor', 'middle')
    .attr('class', 'title')
    .text("Diverted Flights");

    // Create on-time subplot SVG container
    const onTimeSubplotSVG = d3.create("svg")
    .attr("width", subplotWidth)
    .attr("height", subplotHeight);

    // Add x-axis
    onTimeSubplotSVG.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
    .call(d3.axisBottom(subplotX));

    // Add title
    onTimeSubplotSVG.append("text")
    .attr('x', subplotWidth / 2)
    .attr('y', 10)
    .attr('font-size', '12px')
    .attr('text-anchor', 'middle')
    .attr('class', 'title')
    .text("On Time Flights");

    // Add legend
    let subplotLegend = d3.create('svg')
    .attr('class', 'subplotLegend');

    // Monthly Cancellations Slider
    $("#monthlyCancellationsSlider").slider({
        range: true,
        min: minMonthlyFlightsCancelled,
        max: maxMonthlyFlightsCancelled,
        values: [minMonthlyFlightsCancelled, maxMonthlyFlightsCancelled],
        step: 1,
        slide: function(event, ui) {
            document.querySelector("#monthlyCancellationsSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
            filterData("Statistics.Flights.Cancelled", ui.values);
        }
    });

    // Monthly Delays Slider
    $("#monthlyDelaysSlider").slider({
        range: true,
        min: minMonthlyFlightsDelayed,
        max: maxMonthlyFlightsDelayed,
        values: [minMonthlyFlightsDelayed, maxMonthlyFlightsDelayed],
        step: 1,
        slide: function(event, ui) {
            document.querySelector("#monthlyDelaysSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
            filterData("Statistics.Flights.Delayed", ui.values);
        }
    });

    // Monthly Diversions Slider
    $("#monthlyDiversionsSlider").slider({
        range: true,
        min: minMonthlyFlightsDiverted,
        max: maxMonthlyFlightsDiverted,
        values: [minMonthlyFlightsDiverted, maxMonthlyFlightsDiverted],
        step: 1,
        slide: function(event, ui) {
            document.querySelector("#monthlyDiversionsSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
            filterData("Statistics.Flights.Diverted", ui.values);
        }
    });

    // Monthly On-Time Slider
    $("#monthlyOnTimeSlider").slider({
        range: true,
        min: minMonthlyFlightsOnTime,
        max: maxMonthlyFlightsOnTime,
        values: [minMonthlyFlightsOnTime, maxMonthlyFlightsOnTime],
        step: 1,
        slide: function(event, ui) {
            document.querySelector("#monthlyOnTimeSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
            filterData("Statistics.Flights.On Time", ui.values);
        }
    });

    // console.log(document.getElementById("normalizeCheckbox"));

    document.getElementById("normalizeCheckbox").addEventListener('change', function() {

        // Remove everything subplot-related
        clearSubplotsAndLegend();

        if (this.checked) {
            normalize = true;
            setSlidersToNormalized();
            setSliderRangesToNormalized();
            svg.selectAll('circle').remove();
            
        } else {
            normalize = false;
            setSlidersToUnnormalized();
            setSliderRangesToUnnormalized();
            svg.selectAll('circle').remove();
        }
    });

    document.getElementById("resetButton").addEventListener('click', () => {
        clearSubplotsAndLegend();
        document.getElementById('normalizeCheckbox').checked = false;
        setSlidersToUnnormalized();
        setSliderRangesToUnnormalized();
        svg.selectAll('circle').remove();
    });

    const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

    // function checkNormalize(e) {
    //     if (e.checked) {
    //         console.log("Checked");
    //     } else {
    //         console.log("Unchecked");
    //     }
    // }

    function compareStrings(a, b) {
        return a < b;
    }

    function filterData(attr, values) {
        for (let i = 0; i < attributes.length; i++) {
            if (attr == attributes[i]) {
                if (normalize) {
                    rangesNormalized[i] = values;
                } else {
                    ranges[i] = values;
                }
            }
        }
        
        var toVisualize = data.filter(function(d) {
            return isInRange(d);
        });
        updateVis(toVisualize);
    }

    function isInRange(data) {
        for (let i = 0; i < attributes.length; i++) {
            // console.log(data);
            let totalFlights = parseInt(data['Statistics.Flights.Total']);
            // console.log('Total Flights: ' + totalFlights);
            // console.log('Cancellations: ' + data[attributes[i]]);
            // console.log('Math: ' + (data[attributes[i]] / totalFlights))
            // console.log('More math: ' + ((data[attributes[i]] / totalFlights) * 1000.0));
            if (normalize) {
                let attrPer1k = parseFloat(data[attributes[i]]) / totalFlights * 1000.0;
                // console.log(attrPer1k);
                // console.log(rangesNormalized[i][0]);
                // console.log(rangesNormalized[i][1]);

                if (attrPer1k < rangesNormalized[i][0] || attrPer1k > rangesNormalized[i][1]) {
                    return false;
                }
            } else {
                if (data[attributes[i]] < ranges[i][0] || data[attributes[i]] > ranges[i][1]) {
                    return false;
                }
            }
        }

        return true;
    }

    function updateVis(toVisualize) {
        currentData = toVisualize;
        let airportYearDict = {};

        let svg = d3.select("svg")

        svg.selectAll("circle").data(toVisualize).join("circle")
        .attr("r", 10)
        .attr("cx", function(d) {return x(parseInt(d['Time.Year']))})
        .attr("cy", function(d) {return y(d['Airport.Name'])})
        .attr("rowId", function(d) {return airportDict[d['Airport.Name']]})
        .attr('class', 'mainDot')
        // .style("fill-opacity", 1/12)
        .style('fill', function(d) {
            let key = d['Airport.Name'] + ' ' + d['Time.Year'];

            if (airportYearDict[key] == null) {
                airportYearDict[key] = 1;
            } else {
                airportYearDict[key] += 1;
            }

            let totalMonths = airportYearDict[key];

            if (totalMonths == 0) {
                return mainPlotColorScale(0);
            } else if (totalMonths < 4) {
                return mainPlotColorScale(1/4);
            } else if (totalMonths < 7) {
                return mainPlotColorScale(2/4);
            } else if (totalMonths < 10) {
                return mainPlotColorScale(3/4);
            } else if (totalMonths < 13) {
                return mainPlotColorScale(1);
            }
        })
        .style("stroke", "black")
        .on("mouseover", (event, d) => {
            let text = getMainPlotTooltipText(d);

            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(text).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 20) + "px");
            highlight(airportDict[d['Airport.Name']]);
        })
        .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
            unhighlight();
        })
        .on("click", (event, d) => {
            let dataYear = parseInt(d['Time.Year']);
            let newSelection = [];

            if (selectedSubplotDataYear != dataYear) {
                clearSubplotsAndLegend();
                selectedSubplotDataYear = dataYear;
            }
            
            for (let i = 0; i < data.length; i++) {
                if (data[i]['Airport.Name'] == d['Airport.Name'] && data[i]['Time.Year'] == dataYear) {
                    selectedSubplotData.push(data[i]);
                }
            }
            selectedSubplotData = [...new Set(selectedSubplotData)];

            updateCancelledSubplotYAxis();
            updateDelayedSubplotYAxis();
            updateDivertedSubplotYAxis();
            updateOnTimeSubplotYAxis();
            
            updateSubplotXAxis();
            
            updateCancelledSubplotVis();
            updateDelayedSubplotVis();
            updateDivertedSubplotVis();
            updateOnTimeSubplotVis();

            updateSubplotTitles();
        });
    }

    function getMainPlotTooltipText(data) {
        let output = `${data['Airport.Name']}<br>`;

        for (let i = 0; i < currentData.length; i++) {
            if (currentData[i]['Airport.Name'] == data['Airport.Name'] && currentData[i]['Time.Year'] == data['Time.Year']) {
                output = output + currentData[i]['Time.Month Name'] + ' ' + currentData[i]['Time.Year'] + '<br>';
            }
        }

        return output;
    }

    function getSubplotTooltipText(parameter, data) {
        let output = `${data['Airport.Name']}<br>`;
        let param_value = data[parameter];

        if (normalize) {
            param_value = parseInt(parseFloat(data[parameter]) / parseFloat(data["Statistics.Flights.Total"]) * 1000);
        }

        output = output + data['Time.Month Name'] + ' - ' + param_value;

        return output;
    }

    function highlight(rowId) {
        d3.selectAll(".mainDot").classed("highlight", d => airportDict[d['Airport.Name']] == rowId);
        d3.selectAll(".dot").classed("highlight", d => airportDict[d['Airport.Name']] == rowId);
        d3.selectAll(".dot").classed("dim", d => airportDict[d['Airport.Name']] != rowId);
        d3.selectAll('.line').classed('dim', d => airportDict[d[0]['Airport.Name']] != rowId);
    }

    function unhighlight() {
        d3.selectAll("circle").classed("highlight", false);
        d3.selectAll(".dot").classed("dim", false);
        d3.selectAll('.line').classed('dim', false);
    }

    function updateCancelledSubplotYAxis() {
        let axisAirports = Array.from(new Set(selectedSubplotData.map(d => d["Airport.Name"]))).sort(compareStrings);
        let minFlightsCancelled = d3.min(selectedSubplotData, d => parseInt(d['Statistics.Flights.Cancelled']));
        let maxFlightsCancelled = d3.max(selectedSubplotData, d => parseInt(d['Statistics.Flights.Cancelled']));

        if (normalize) {
            minFlightsCancelled = d3.min(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            maxFlightsCancelled = d3.max(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
        }
        // console.log('Min and Max: ' + minFlightsCancelled + ' ' + maxFlightsCancelled);

        cancelledSubplotY = d3.scaleLinear()
        .domain([minFlightsCancelled, maxFlightsCancelled])
        .range([subplotHeight - marginBottom, marginTop]);

        if (!cancelledSubplotYAxisExists) {
            cancelledSubplotSVG.append('g').attr("class", 'y-axis');
            cancelledSubplotYAxisExists = true;
        }

        cancelledSubplotSVG.select(".y-axis")
        .attr("transform", `translate(${subplotMarginLeft},0)`)
        .call(d3.axisLeft(cancelledSubplotY).ticks(10));
    }

    function updateDelayedSubplotYAxis() {
        let axisAirports = Array.from(new Set(selectedSubplotData.map(d => d["Airport.Name"]))).sort(compareStrings);
        let minFlightsDelayed = d3.min(selectedSubplotData, d => parseInt(d['Statistics.Flights.Delayed']));
        let maxFlightsDelayed = d3.max(selectedSubplotData, d => parseInt(d['Statistics.Flights.Delayed']));

        if (normalize) {
            minFlightsDelayed = d3.min(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Delayed"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            maxFlightsDelayed = d3.max(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Delayed"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
        }

        delayedSubplotY = d3.scaleLinear()
        .domain([minFlightsDelayed, maxFlightsDelayed])
        .range([subplotHeight - marginBottom, marginTop]);

        if (!delayedSubplotYAxisExists) {
            delayedSubplotSVG.append('g').attr("class", 'y-axis');
            delayedSubplotYAxisExists = true;
        }

        delayedSubplotSVG.select(".y-axis")
        .attr("transform", `translate(${subplotMarginLeft},0)`)
        .call(d3.axisLeft(delayedSubplotY).ticks(10));
    }

    function updateDivertedSubplotYAxis() {
        let axisAirports = Array.from(new Set(selectedSubplotData.map(d => d["Airport.Name"]))).sort(compareStrings);
        let minFlightsDiverted = d3.min(selectedSubplotData, d => parseInt(d['Statistics.Flights.Diverted']));
        let maxFlightsDiverted = d3.max(selectedSubplotData, d => parseInt(d['Statistics.Flights.Diverted']));

        if (normalize) {
            minFlightsDiverted = d3.min(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Diverted"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            maxFlightsDiverted = d3.max(selectedSubplotData, d => parseFloat(d["Statistics.Flights.Diverted"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
        }

        divertedSubplotY = d3.scaleLinear()
        .domain([minFlightsDiverted, maxFlightsDiverted])
        .range([subplotHeight - marginBottom, marginTop]);

        if (!divertedSubplotYAxisExists) {
            divertedSubplotSVG.append('g').attr("class", 'y-axis');
            divertedSubplotYAxisExists = true;
        }

        divertedSubplotSVG.select(".y-axis")
        .attr("transform", `translate(${subplotMarginLeft},0)`)
        .call(d3.axisLeft(divertedSubplotY).ticks(10));
    }

    function updateOnTimeSubplotYAxis() {
        let axisAirports = Array.from(new Set(selectedSubplotData.map(d => d["Airport.Name"]))).sort(compareStrings);
        let minFlightsOnTime = d3.min(selectedSubplotData, d => parseInt(d['Statistics.Flights.On Time']));
        let maxFlightsOnTime = d3.max(selectedSubplotData, d => parseInt(d['Statistics.Flights.On Time']));

        if (normalize) {
            minFlightsOnTime = d3.min(selectedSubplotData, d => parseFloat(d["Statistics.Flights.On Time"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            maxFlightsOnTime = d3.max(selectedSubplotData, d => parseFloat(d["Statistics.Flights.On Time"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
        }

        onTimeSubplotY = d3.scaleLinear()
        .domain([minFlightsOnTime, maxFlightsOnTime])
        .range([subplotHeight - marginBottom, marginTop]);

        if (!onTimeSubplotYAxisExists) {
            onTimeSubplotSVG.append('g').attr("class", 'y-axis');
            onTimeSubplotYAxisExists = true;
        }

        onTimeSubplotSVG.select(".y-axis")
        .attr("transform", `translate(${subplotMarginLeft},0)`)
        .call(d3.axisLeft(onTimeSubplotY).ticks(10));
    }

    function updateSubplotXAxis() {
        let months = [];
        if (selectedSubplotDataYear == 2003) {
            months = ['June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
        } else if (selectedSubplotDataYear == 2016) {
            months = ['Jan'];
        } else {
            months = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
        }

        subplotX = d3.scaleBand()
        .domain(months)
        .range([subplotMarginLeft, subplotWidth - marginRight])
        .padding(1);

        // Update x-axis for cancelled subplot
        cancelledSubplotSVG.select(".x-axis")
        .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
        .call(d3.axisBottom(subplotX));

        // Update x-axis for delayed subplot
        delayedSubplotSVG.select(".x-axis")
        .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
        .call(d3.axisBottom(subplotX));

        // Update x-axis for diverted subplot
        divertedSubplotSVG.select(".x-axis")
        .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
        .call(d3.axisBottom(subplotX));

        // Update x-axis for on time subplot
        onTimeSubplotSVG.select(".x-axis")
        .attr("transform", `translate(0,${subplotHeight - marginBottom})`)
        .call(d3.axisBottom(subplotX));
    }

    function updateCancelledSubplotVis() {
        let selectedAirports = Array.from(new Set(selectedSubplotData.map(data => data['Airport.Name'])));
        subplotColors.domain(selectedAirports);

        let arrayedSubplotData = [];
        let size = 12;

        if (selectedSubplotDataYear == 2003) {
            size = 7;
        } else if (selectedSubplotDataYear == 2016) {
            size = 1;
        }

        let selection = [selectedSubplotData[0]]
        for (let i = 1; i < selectedSubplotData.length; i++) {
            selection.push(selectedSubplotData[i]);

            if ((i + 1) % size == 0) {
                arrayedSubplotData.push(selection);
                selection = [];
            }
        }

        let line = d3.line()
        .x(d => subplotX(monthDict[d['Time.Month Name']]))
        .y(d => cancelledSubplotY(d['Statistics.Flights.Cancelled']));

        if (normalize) {
            line = d3.line()
            .x(d => subplotX(monthDict[d['Time.Month Name']]))
            .y(d => cancelledSubplotY(parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
        }

        // Remove old lines first
        if (selectedSubplotDataYear != 2016) {
            cancelledSubplotSVG.selectAll('.line')
            .remove();
        }

        // Add lines
        if (selectedSubplotDataYear != 2016) {
            cancelledSubplotSVG.selectAll('.line')
            .data(arrayedSubplotData)
            .enter()
            .append('path')
            .attr('class', 'line')
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke-width', '4px')
            .attr('stroke', d => subplotColors(d[0]['Airport.Name']));
        }

        // Remove old dots first
        cancelledSubplotSVG.selectAll('.dot').remove();        

        // Add monthly dots
        cancelledSubplotSVG.selectAll('.dot')
        .data(selectedSubplotData)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('r', 4)
        .attr('cx', function(d) {return subplotX(monthDict[d['Time.Month Name']])})
        .attr('cy', function(d) {
            if (normalize) {
                return cancelledSubplotY(parseFloat(d["Statistics.Flights.Cancelled"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            } else {
                return cancelledSubplotY(parseFloat(d["Statistics.Flights.Cancelled"]))
            }
        })
        .style('fill', d => subplotColors(d['Airport.Name']))
        .style('stroke', 'black')
        .on("mouseover", (event, d) => {
            let text = getSubplotTooltipText('Statistics.Flights.Cancelled', d);
            // console.log(text);

            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(text).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 20) + "px");
            highlight(airportDict[d['Airport.Name']]);
        })
        .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
            unhighlight();
        });


        // Update legend
        updateSubplotLegend(selectedAirports);
    }

    function updateDelayedSubplotVis() {
        let selectedAirports = Array.from(new Set(selectedSubplotData.map(data => data['Airport.Name'])));
        subplotColors.domain(selectedAirports);

        let arrayedSubplotData = [];
        let size = 12;

        if (selectedSubplotDataYear == 2003) {
            size = 7;
        } else if (selectedSubplotDataYear == 2016) {
            size = 1;
        }

        let selection = [selectedSubplotData[0]]
        for (let i = 1; i < selectedSubplotData.length; i++) {
            selection.push(selectedSubplotData[i]);

            if ((i + 1) % size == 0) {
                arrayedSubplotData.push(selection);
                selection = [];
            }
        }

        let line = d3.line()
        .x(d => subplotX(monthDict[d['Time.Month Name']]))
        .y(d => delayedSubplotY(d['Statistics.Flights.Delayed']));

        if (normalize) {
            line = d3.line()
            .x(d => subplotX(monthDict[d['Time.Month Name']]))
            .y(d => delayedSubplotY(parseFloat(d["Statistics.Flights.Delayed"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
        }

        // Remove old lines first
        if (selectedSubplotDataYear != 2016) {
            delayedSubplotSVG.selectAll('.line')
            .remove();
        }

        // Add lines
        if (selectedSubplotDataYear != 2016) {
            delayedSubplotSVG.selectAll('.line')
            .data(arrayedSubplotData)
            .enter()
            .append('path')
            .attr('class', 'line')
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke-width', '4px')
            .attr('stroke', d => subplotColors(d[0]['Airport.Name']));
        }

        // Remove old dots first
        delayedSubplotSVG.selectAll('.dot').remove();
        
        // Add monthly dots
        delayedSubplotSVG.selectAll('.dot')
        .data(selectedSubplotData)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('r', 4)
        .attr('cx', function(d) {return subplotX(monthDict[d['Time.Month Name']])})
        .attr('cy', function(d) {
            if (normalize) {
                return delayedSubplotY(parseFloat(d["Statistics.Flights.Delayed"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            } else {
                return delayedSubplotY(parseFloat(d["Statistics.Flights.Delayed"]))
            }
        })
        .style('fill', d => subplotColors(d['Airport.Name']))
        .style('stroke', 'black')
        .on("mouseover", (event, d) => {
            let text = getSubplotTooltipText('Statistics.Flights.Delayed', d);
            // console.log(text);

            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(text).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 20) + "px");
            highlight(airportDict[d['Airport.Name']]);
        })
        .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
            unhighlight();
        });

        // Update legend
        updateSubplotLegend(selectedAirports);
    }

    function updateDivertedSubplotVis() {
        let selectedAirports = Array.from(new Set(selectedSubplotData.map(data => data['Airport.Name'])));
        subplotColors.domain(selectedAirports);

        let arrayedSubplotData = [];
        let size = 12;

        if (selectedSubplotDataYear == 2003) {
            size = 7;
        } else if (selectedSubplotDataYear == 2016) {
            size = 1;
        }

        let selection = [selectedSubplotData[0]]
        for (let i = 1; i < selectedSubplotData.length; i++) {
            selection.push(selectedSubplotData[i]);

            if ((i + 1) % size == 0) {
                arrayedSubplotData.push(selection);
                selection = [];
            }
        }

        let line = d3.line()
        .x(d => subplotX(monthDict[d['Time.Month Name']]))
        .y(d => divertedSubplotY(d['Statistics.Flights.Diverted']));

        if (normalize) {
            line = d3.line()
            .x(d => subplotX(monthDict[d['Time.Month Name']]))
            .y(d => divertedSubplotY(parseFloat(d["Statistics.Flights.Diverted"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
        }

        // Remove old lines first
        if (selectedSubplotDataYear != 2016) {
            divertedSubplotSVG.selectAll('.line')
            .remove();
        }

        // Add lines
        if (selectedSubplotDataYear != 2016) {
            divertedSubplotSVG.selectAll('.line')
            .data(arrayedSubplotData)
            .enter()
            .append('path')
            .attr('class', 'line')
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke-width', '4px')
            .attr('stroke', d => subplotColors(d[0]['Airport.Name']));
        }

        // Remove old dots first
        divertedSubplotSVG.selectAll('.dot').remove();
        
        // Add monthly dots
        divertedSubplotSVG.selectAll('.dot')
        .data(selectedSubplotData)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('r', 4)
        .attr('cx', function(d) {return subplotX(monthDict[d['Time.Month Name']])})
        .attr('cy', function(d) {
            if (normalize) {
                return divertedSubplotY(parseFloat(d["Statistics.Flights.Diverted"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            } else {
                return divertedSubplotY(parseFloat(d["Statistics.Flights.Diverted"]))
            }
        })
        .style('fill', d => subplotColors(d['Airport.Name']))
        .style('stroke', 'black')
        .on("mouseover", (event, d) => {
            let text = getSubplotTooltipText('Statistics.Flights.Diverted', d);
            // console.log(text);

            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(text).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 20) + "px");
            highlight(airportDict[d['Airport.Name']]);
        })
        .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
            unhighlight();
        });

        // Update legend
        updateSubplotLegend(selectedAirports);
    }

    function updateOnTimeSubplotVis() {
        let selectedAirports = Array.from(new Set(selectedSubplotData.map(data => data['Airport.Name'])));
        subplotColors.domain(selectedAirports);

        let arrayedSubplotData = [];
        let size = 12;

        if (selectedSubplotDataYear == 2003) {
            size = 7;
        } else if (selectedSubplotDataYear == 2016) {
            size = 1;
        }

        let selection = [selectedSubplotData[0]]
        for (let i = 1; i < selectedSubplotData.length; i++) {
            selection.push(selectedSubplotData[i]);

            if ((i + 1) % size == 0) {
                arrayedSubplotData.push(selection);
                selection = [];
            }
        }

        let line = d3.line()
        .x(d => subplotX(monthDict[d['Time.Month Name']]))
        .y(d => onTimeSubplotY(d['Statistics.Flights.On Time']));

        if (normalize) {
            line = d3.line()
            .x(d => subplotX(monthDict[d['Time.Month Name']]))
            .y(d => onTimeSubplotY(parseFloat(d["Statistics.Flights.On Time"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000));
        }

        // Remove old lines first
        if (selectedSubplotDataYear != 2016) {
            onTimeSubplotSVG.selectAll('.line')
            .remove();
        }

        // Add lines
        if (selectedSubplotDataYear != 2016) {
            onTimeSubplotSVG.selectAll('.line')
            .data(arrayedSubplotData)
            .enter()
            .append('path')
            .attr('class', 'line')
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke-width', '4px')
            .attr('stroke', d => subplotColors(d[0]['Airport.Name']));
        }

        // Remove old dots first
        onTimeSubplotSVG.selectAll('.dot').remove();

        // Add monthly dots
        onTimeSubplotSVG.selectAll('.dot')
        .data(selectedSubplotData)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('r', 4)
        .attr('cx', function(d) {return subplotX(monthDict[d['Time.Month Name']])})
        .attr('cy', function(d) {
            if (normalize) {
                return onTimeSubplotY(parseFloat(d["Statistics.Flights.On Time"]) / parseFloat(d["Statistics.Flights.Total"]) * 1000);
            } else {
                return onTimeSubplotY(parseFloat(d["Statistics.Flights.On Time"]))
            }
        })
        .style('fill', d => subplotColors(d['Airport.Name']))
        .style('stroke', 'black')
        .on("mouseover", (event, d) => {
            let text = getSubplotTooltipText('Statistics.Flights.On Time', d);
            // console.log(text);

            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(text).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 20) + "px");
            highlight(airportDict[d['Airport.Name']]);
        })
        .on("mouseout", () => {
            tooltip.transition().duration(500).style("opacity", 0);
            unhighlight();
        });

        // Update legend
        updateSubplotLegend(selectedAirports);
    }

    function updateSubplotLegend(selectedAirports) {
        subplotLegend.selectAll('rect')
        .data(selectedAirports)
        .enter()
        .append('rect')
        .attr('x', 0)
        .attr('y', (d, i) => i * 15 + 5)
        .attr('width', 20)
        .attr('height', 10)
        .attr('fill', d => subplotColors(d))
        .attr('class', 'legendBar')
        .on('mouseover', (event, d) => {
            highlight(airportDict[d]);
        })
        .on('mouseout', () => {
            unhighlight();
        });

        subplotLegend.selectAll('text')
        .data(selectedAirports)
        .enter()
        .append('text')
        .attr('x', 22)
        .attr('y', (d, i) => i * 15 + 15)
        .attr('class', 'legendLabel')
        .text(d => d)
        .style('font-size', '12px')
        .on('mouseover', (event, d) => {
            highlight(airportDict[d]);
        })
        .on('mouseout', () => {
            unhighlight();
        });
    }

    function clearSubplotsAndLegend() {
        cancelledSubplotSVG.selectAll('.line').remove();
        cancelledSubplotSVG.selectAll('.dot').remove();
        delayedSubplotSVG.selectAll('.line').remove();
        delayedSubplotSVG.selectAll('.dot').remove();
        divertedSubplotSVG.selectAll('.line').remove();
        divertedSubplotSVG.selectAll('.dot').remove();
        onTimeSubplotSVG.selectAll('.line').remove();
        onTimeSubplotSVG.selectAll('.dot').remove();
        subplotLegend.selectAll('.legendBar').remove();
        subplotLegend.selectAll('.legendLabel').remove();
        selectedSubplotData = [];
    }

    function setSlidersToUnnormalized() {
        // Monthly Cancellations Slider
        $("#monthlyCancellationsSlider").slider({
            range: true,
            min: minMonthlyFlightsCancelled,
            max: maxMonthlyFlightsCancelled,
            values: [minMonthlyFlightsCancelled, maxMonthlyFlightsCancelled],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyCancellationsSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.Cancelled", ui.values);
            }
        });

        // Monthly Delays Slider
        $("#monthlyDelaysSlider").slider({
            range: true,
            min: minMonthlyFlightsDelayed,
            max: maxMonthlyFlightsDelayed,
            values: [minMonthlyFlightsDelayed, maxMonthlyFlightsDelayed],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyDelaysSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.Delayed", ui.values);
            }
        });

        // Monthly Diversions Slider
        $("#monthlyDiversionsSlider").slider({
            range: true,
            min: minMonthlyFlightsDiverted,
            max: maxMonthlyFlightsDiverted,
            values: [minMonthlyFlightsDiverted, maxMonthlyFlightsDiverted],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyDiversionsSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.Diverted", ui.values);
            }
        });

        // Monthly On-Time Slider
        $("#monthlyOnTimeSlider").slider({
            range: true,
            min: minMonthlyFlightsOnTime,
            max: maxMonthlyFlightsOnTime,
            values: [minMonthlyFlightsOnTime, maxMonthlyFlightsOnTime],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyOnTimeSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.On Time", ui.values);
            }
        });
    }

    function setSlidersToNormalized() {
        // Monthly Cancellations Slider
        $("#monthlyCancellationsSlider").slider({
            range: true,
            min: minMonthlyFlightsCancelledNorm,
            max: maxMonthlyFlightsCancelledNorm,
            values: [minMonthlyFlightsCancelledNorm, maxMonthlyFlightsCancelledNorm],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyCancellationsSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.Cancelled", ui.values);
            }
        });

        // Monthly Delays Slider
        $("#monthlyDelaysSlider").slider({
            range: true,
            min: minMonthlyFlightsDelayedNorm,
            max: maxMonthlyFlightsDelayedNorm,
            values: [minMonthlyFlightsDelayedNorm, maxMonthlyFlightsDelayedNorm],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyDelaysSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.Delayed", ui.values);
            }
        });

        // Monthly Diversions Slider
        $("#monthlyDiversionsSlider").slider({
            range: true,
            min: minMonthlyFlightsDivertedNorm,
            max: maxMonthlyFlightsDivertedNorm,
            values: [minMonthlyFlightsDivertedNorm, maxMonthlyFlightsDivertedNorm],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyDiversionsSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.Diverted", ui.values);
            }
        });

        // Monthly On-Time Slider
        $("#monthlyOnTimeSlider").slider({
            range: true,
            min: minMonthlyFlightsOnTimeNorm,
            max: maxMonthlyFlightsOnTimeNorm,
            values: [minMonthlyFlightsOnTimeNorm, maxMonthlyFlightsOnTimeNorm],
            step: 1,
            slide: function(event, ui) {
                document.querySelector("#monthlyOnTimeSliderValues").textContent = "Range: " + ui.values[0] + "-" + ui.values[1];
                filterData("Statistics.Flights.On Time", ui.values);
            }
        });
    }

    function setSliderRangesToUnnormalized() {
        document.querySelector("#monthlyCancellationsSliderValues").textContent = "Range: " + minMonthlyFlightsCancelled + "-" + maxMonthlyFlightsCancelled;
        document.querySelector("#monthlyDelaysSliderValues").textContent = "Range: " + minMonthlyFlightsDelayed + "-" + maxMonthlyFlightsDelayed;
        document.querySelector("#monthlyDiversionsSliderValues").textContent = "Range: " + minMonthlyFlightsDiverted + "-" + maxMonthlyFlightsDiverted;
        document.querySelector("#monthlyOnTimeSliderValues").textContent = "Range: " + minMonthlyFlightsOnTime + "-" + maxMonthlyFlightsOnTime;
    }

    function setSliderRangesToNormalized() { 
        document.querySelector("#monthlyCancellationsSliderValues").textContent = "Range: " + minMonthlyFlightsCancelledNorm + "-" + maxMonthlyFlightsCancelledNorm;
        document.querySelector("#monthlyDelaysSliderValues").textContent = "Range: " + minMonthlyFlightsDelayedNorm + "-" + maxMonthlyFlightsDelayedNorm;
        document.querySelector("#monthlyDiversionsSliderValues").textContent = "Range: " + minMonthlyFlightsDivertedNorm + "-" + maxMonthlyFlightsDivertedNorm;
        document.querySelector("#monthlyOnTimeSliderValues").textContent = "Range: " + minMonthlyFlightsOnTimeNorm + "-" + maxMonthlyFlightsOnTimeNorm;
    }

    function updateSubplotTitles() {
        cancelledSubplotSVG.select('.title')
        .text(selectedSubplotDataYear + ' Cancelled Flights');
        
        delayedSubplotSVG.select('.title')
        .text(selectedSubplotDataYear + ' Delayed Flights');

        divertedSubplotSVG.select('.title')
        .text(selectedSubplotDataYear + ' Diverted Flights');

        onTimeSubplotSVG.select('.title')
        .text(selectedSubplotDataYear + ' On Time Flights');
    }
    
    // Append the SVG element.
    container.append(svg.node());
    container.append(mainPlotLegend.node());
    firstSubplotContainer.append(cancelledSubplotSVG.node());
    firstSubplotContainer.append(delayedSubplotSVG.node());
    secondSubplotContainer.append(divertedSubplotSVG.node());
    secondSubplotContainer.append(onTimeSubplotSVG.node());
    subplotMainContainer.append(subplotLegend.node());
    setSliderRangesToUnnormalized();
</script>



